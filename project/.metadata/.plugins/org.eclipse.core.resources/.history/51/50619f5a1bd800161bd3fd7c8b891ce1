/*import java.util.ArrayList;
import java.util.Scanner;
import java.util.Random;*/
import java.util.*;
import java.io.BufferedReader;
import java.io.FileReader;
import javax.swing.*;

import IPProgrammingExamples.IP_model_unit;
import gurobi.*;

import java.awt.*;

public class Main {


  static Algorithm algorithm;
  
  public static void main(String[] args) {

	/*
	Scanner standardInput = new Scanner(System.in);
	System.out.print("Enter a file name or x to generate random instances: ");
	String choice = standardInput.nextLine();

    // #NOTE for all cases project students wants to be assigned is undersubscribed
    // pass in a 1 as an argument if u want to run this version

    if (!choice.equals("x")) {

      algorithm = instanceGenerator(choice);

      createRankingLists();

      algorithm.s.stabilityChecker(algorithm.assignedStudents, algorithm.unassigned, algorithm.emptyProject);
      algorithm.s.checkAssignedStudentsForBlockingPairs(algorithm.assignedStudents);
      algorithm.s.checkUnassignedStudentsForBlockingPairs(algorithm.unassigned);

    } else {
      // Done so we know what the arguments actually do
      System.out.print("Enter how many instances you would like to generate ");
      int numberOfInstances = Integer.parseInt(standardInput.nextLine());

      System.out.print("Enter how many projects you would like to generate ");
      int numberOfProjects = Integer.parseInt(standardInput.nextLine());

      System.out.print("Enter how many students you would like to generate ");
      int numberOfStudents = Integer.parseInt(standardInput.nextLine());

      System.out.print("Enter how many lecturers you would like to generate ");
      int numberOfLecturers = Integer.parseInt(standardInput.nextLine());

      System.out.print("Enter how much extra capacity for lecturers you would like ");
      int lecturerCapacity = Integer.parseInt(standardInput.nextLine());

      System.out.print("Enter how much extra capacity for projects you would like ");
      int projectCapacity = Integer.parseInt(standardInput.nextLine());

      int[] arguments = new int[] {numberOfProjects, numberOfStudents, numberOfLecturers, lecturerCapacity, projectCapacity};

      if (numberOfLecturers + lecturerCapacity < numberOfProjects) {

        while (numberOfLecturers + lecturerCapacity < numberOfProjects) {

          System.out.println("Lecturer + lecturer capacity must be larger than number of projects");

          System.out.print("Enter how many projects you would like to generate ");
          numberOfProjects = Integer.parseInt(standardInput.nextLine());

          System.out.print("Enter how many lecturers you would like to generate ");
          numberOfLecturers = Integer.parseInt(standardInput.nextLine());

          System.out.print("Enter how much extra capacity for lecturers you would like ");
          lecturerCapacity = Integer.parseInt(standardInput.nextLine());
        }
      }
      
      standardInput.close();

      int i = 0;

      while (i<numberOfInstances) {
        go(arguments, args[0]);
        i++;
      }
    }
	*/
  }

  static Algorithm instanceGenerator(String fileName) {
    Algorithm algorithm = new Algorithm();
    try {

      BufferedReader br = new BufferedReader(new FileReader(fileName));

      String[] splitted = br.readLine().split(" ");

      int numProjects = Integer.parseInt(splitted[0]);

      int numStudents = Integer.parseInt(splitted[1]);

      int numLecturers = Integer.parseInt(splitted[2]);

      Student currentStudent;

      Student untouchedStudent;

      // Do projects first, track their lecturer and assign at the end
      Project currentProject;

      for (int i = 0; i < numProjects; i++) {

        splitted = br.readLine().split(" ");
        currentProject = new Project(splitted[0], Integer.parseInt(splitted[1]));
        algorithm.testProjects.add(currentProject);
      }

      // now create students
      for(int i = 0; i < numStudents; i++) {

        splitted = br.readLine().split(" "); // get each student
        currentStudent = new Student(splitted[0].substring(0, splitted[0].length()-1));
        algorithm.unassigned.add(currentStudent); // creates student with new name
        untouchedStudent =  new Student(splitted[0].substring(0, splitted[0].length()-1));
        algorithm.untouchedStudents.add(untouchedStudent); // creates student with new name

        for (int j = 1; j < splitted.length; j++) {
          currentStudent.preferenceList.add(algorithm.testProjects.get(Integer.parseInt(splitted[j])-1));
          untouchedStudent.preferenceList.add(algorithm.testProjects.get(Integer.parseInt(splitted[j])-1));
        }

        currentStudent.rankingList = new int[currentStudent.preferenceList.size()];

		    for (int k = 0; k < currentStudent.preferenceList.size(); k++) {
				  currentStudent.rankingList[k] = k;  // Initially set rankings so index 0 is favourite, 1 is second favourite etc..
			  }
      }

      Lecturer currentLecturer;
      // now create lecturers

      for (int i = 0; i < numLecturers; i++) {

        splitted = br.readLine().split(" ");
        currentLecturer = new Lecturer(splitted[0].substring(0, splitted[0].length()-1), Integer.parseInt(splitted[1].substring(0, splitted[0].length()-1)));
        algorithm.testLecturers.add(currentLecturer);
        for (int j = 2; j < splitted.length; j++) {
          currentLecturer.projects.add(algorithm.testProjects.get(Integer.parseInt(splitted[j].replace(":", ""))-1));
          algorithm.testProjects.get(Integer.parseInt(splitted[j])-1).lecturer = currentLecturer;
        }
      }

      String line;

      // add matchings
      ArrayList<Student> toBeRemoved = new ArrayList<Student>();
      Project matchingProject;
      int projectNumber;

      // #TODO if there are matches edit currentstudents rankingList
      while ((line = br.readLine()) != null) {

        splitted = line.split(",");
        currentStudent = algorithm.unassigned.get(Integer.parseInt(splitted[0].substring(1, splitted[0].length())) - 1);
        toBeRemoved.add(currentStudent);
        projectNumber = Integer.parseInt(splitted[1].substring(0, splitted[0].length()-1))-1;
        projectNumber = currentStudent.preferenceList.indexOf(algorithm.testProjects.get(projectNumber)); // get index of project in students pref list
        matchingProject = algorithm.testProjects.get(projectNumber);
        currentStudent.proj = matchingProject;
        currentStudent.rankingListTracker = projectNumber;    // for stability checking purposes
        matchingProject.unpromoted.add(currentStudent);
        matchingProject.lecturer.assigned++;
      }

      br.close();
      
      algorithm.assignedStudents.addAll(toBeRemoved);
      algorithm.unassigned.removeAll(toBeRemoved);

    } catch (Exception e) {
      System.out.println("Type of error: " + e.getClass().getName() + " Error message: " + e.getMessage());
    }
    return algorithm;
  }

  public void go(int[] arguments, boolean promotion) {
	  /*int maxMatchingSize = Integer.MIN_VALUE;
	  int minMatchingSize = Integer.MAX_VALUE;
	  int cumulativeMatchingSize = 0;
	  int matchingSize;
	  
	  for (int i = 0; i < arguments[5]; i++){
	      if (promotion){
	        algorithm = new ApproxPromotion();
	      }else {
	      	algorithm = new Approx();
	      }
	      algorithm.instances = arguments[5];
	      populate(arguments); // args0 is number of students to generate
	      assignCapacity(arguments[3], arguments[4]);	//assigns capacity to the projects, args are lecturer capacity and project capacity
	      assignProjectsToLecturers(); // Associate project with a lecturer
	
	      if (promotion){
	        algorithm.spaPApproxPromotion();
	      } else {
	        algorithm.assignProjectsToStudents();
	      }
	      
	      if (algorithm.instances == 1) {
		      algorithm.printInstance();
		      algorithm.s.stabilityChecker(algorithm.assignedStudents, algorithm.unassigned, algorithm.emptyProject);
	      } else {
	    	  matchingSize = algorithm.assignedStudents.size();
	    	  cumulativeMatchingSize += matchingSize;
	    	  if (matchingSize > maxMatchingSize){
	    		  maxMatchingSize = matchingSize;
	    	  }
	    	  if (matchingSize < minMatchingSize) {
	    		  minMatchingSize = matchingSize;
	    	  }
	      }
	  }
      //arguments are average matching size, max matching size and min matching size
      algorithm.printMatchingOutput(cumulativeMatchingSize/arguments[5], maxMatchingSize, minMatchingSize);
      */
	  
	  // commenting out while we try to set up the grbmodel
	  try {
		setUpGRBModel();
	} catch (GRBException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
	}
  }

  static void setUpGRBModel() throws GRBException {
	  try {
	      // the GRB model is set up and variables are added to model

	        // create the GRBmodel
		  GRBEnv env = new GRBEnv();
		  
		  /** <p>The gurobi model.</p> */
		  algorithm.grbmodel = new GRBModel(env);
	      algorithm.grbmodel.getEnv().set(GRB.IntParam.OutputFlag, 0);
	
	      // add upper and lower quota constraints for projects and lecturers, and student upper quota (of 1)
	      upperLowerConstraints();
	
	      String infoString = "# Information:\n";
	
	
	      infoString += "# - Optimisation: finds a maximum sized matching\n";
	      addMaxSizeConstraint();
	          
	      infoString += "# - Optimisation: finds a minimum sum of student ranks\n";
	      minSumStudentRanks();        
	  
	
	      grbmodel.optimize();
	      int status = grbmodel.get(GRB.IntAttr.Status);
	      if (status != GRB.Status.OPTIMAL) {
	          m.feasible = false;
	          System.out.println("no solution found in the following instance:");
	      }
	      else {
	          setStudentAssignments();
	      }
	      
	
	      // write model then dispose of model and environment
	      m.setInfoString(infoString);
	      //grbmodel.write("SPA_IP_HR.lp");
	      grbmodel.dispose();
	      env.dispose();
	  }
	
	  catch (GRBException e) {
	      System.out.println("Error code: " + e.getErrorCode() + ". " + e.getMessage());
	  }  
  }
  
  /**
   * <p>Adds upper and lower quota constraints to projects and lecturers, and student upper quota.</p>
   */
   static void upperLowerConstraints() throws GRBException {
	   
	   // set up the unitArray and add to project and lecturer lists as go along
       IP_model_unit[][] unitArray = new IP_model_unit[algorithm.unassigned.size()][];
       
       // ----------------------------------------------------------------------------------------
       // each student is matched to 1 or less projects
       for (int x = 0; x < algorithm.unassigned.size(); x++) {
           // get linear expression for the sum of all variables for a student
           GRBLinExpr sumVarsForStudent = new GRBLinExpr();
           for (int y = 0; y < unitArray[x].length; y++) {
               sumVarsForStudent.addTerm(1, unitArray[x][y].studentPrefVar);
           }
           // each student is matched to 1 or less projects
           grbmodel.addConstr(sumVarsForStudent, GRB.LESS_EQUAL, 1.0, "ConstraintStudent" + x);
       }

       // ----------------------------------------------------------------------------------------
       // for each project
       for (int y = 0; y < algorithm.testProjects.size(); y++) {
           // get linear expressions for the sum of variables for this project
           ArrayList<GRBVar> projList = projectLists.get(y);
           GRBLinExpr numStudentsForProj = new GRBLinExpr();
           for (int p = 0; p < projList.size(); p++) {
               numStudentsForProj.addTerm(1, projList.get(p));
           }

           // The number of students a project has must be greater than or equal to the lower quota
           algorithm.grbmodel.addConstr(numStudentsForProj, GRB.GREATER_EQUAL, (double) m.projectLowerQuotas[y], "ConstraintProjectLQ" + y);

           // The number of students a project has must be less than or equal to the max capacity
           algorithm.grbmodel.addConstr(numStudentsForProj, GRB.LESS_EQUAL, (double) m.projUpperQuotas[y], "ConstraintProjectUQ" + y);
           
       }

       // ----------------------------------------------------------------------------------------
       // for each lecturer 
       for (int z = 0; z < algorithm.testLecturers.size(); z++) {
           // get a linear expression for the sum of variables for this lecturer
           ArrayList<IP_model_unit> lecList = lecturerLists.get(z);
           GRBLinExpr numStudentsForLect = new GRBLinExpr();
           for (int var = 0; var < lecList.size(); var++) {  
               numStudentsForLect.addTerm(1, lecList.get(var).studentPrefVar);
           }

           // The number of students a lecturer has must be greater than or equal to the lower quota
           algorithm.grbmodel.addConstr(numStudentsForLect, GRB.GREATER_EQUAL, (double) m.lecturerLowerQuotas[z], "ConstraintLecturerLQ" + z);

           // The number of students a lecturer has must be less than or equal to the max capacity
           algorithm.grbmodel.addConstr(numStudentsForLect, GRB.LESS_EQUAL, (double) m.lecturerUpperQuotas[z], "ConstraintLecturerUQ" + z);
       }
   }
   
  static void assignCapacity(int lecturerCapacity, int projectCapacity) {

		//currently hardcode capacity as 20 but can change to parameter
		Random random = new Random();

		for (int i = 0; i< projectCapacity; i++) {
			algorithm.testProjects.get(random.nextInt(algorithm.testProjects.size())).capacity++;
		}

		for (int i = 0; i< lecturerCapacity; i++) {
		    algorithm.testLecturers.get(random.nextInt(algorithm.testLecturers.size())).capacity++;
		}
	}

	static void populate(int[] args) {
		populateProjects(args[0]);
		populateStudents(args[1]);
		populateLecturers(args[2]);
	}

	static void populateProjects(int numberOfProjects) {
		for (int i = 0; i < numberOfProjects; i++){
			algorithm.testProjects.add(new Project(Integer.toString(i)));
		}
	}


	static void populateStudents(int numberOfStudents) {

		for (int i = 0; i < numberOfStudents; i++){
			algorithm.unassigned.add(new Student(Integer.toString(i)));
      algorithm.untouchedStudents.add(new Student(Integer.toString(i)));
		}

		// populates student preference lists
		double random;
		Random randomProjectIndex = new Random();;
		ArrayList<Project> duplicateList;
		int rPI;
		// need to re-add projects after a student has been assigned all his projects
		for (int j = 0; j <algorithm.unassigned.size(); j++){ //for each projects
			duplicateList = new ArrayList<Project>(algorithm.testProjects);
			random = Math.random()*5;

			// need to ensure we havent removed last item from duplicate list
			for (int i = 0; i < (random + 2) && !duplicateList.isEmpty(); i++) {
				rPI = randomProjectIndex.nextInt(duplicateList.size());
				algorithm.unassigned.get(j).preferenceList.add(duplicateList.get(rPI));
				algorithm.untouchedStudents.get(j).preferenceList.add(duplicateList.get(rPI));
				duplicateList.remove(rPI);
			}

  		}
  	}

    static void populateLecturers(int numberOfLecturers) {
      for (int i = 0; i < numberOfLecturers; i++){
        algorithm.testLecturers.add(new Lecturer(Integer.toString(i)));
      }
    }


  	// for each project: assign random lecturer to project and assign project to lecturer
  	static void assignProjectsToLecturers () {
  		ArrayList<Project> proj = new ArrayList<Project>(algorithm.testProjects);

  		// first assign each lecturer one project
  		Random randomProjectIndex = new Random();
  		for (int i = 0; i < algorithm.testLecturers.size() && proj.size()>0; i++) {
  			int randomInt = randomProjectIndex.nextInt(proj.size());
  			algorithm.testLecturers.get(i).projects.add(proj.get(randomInt));
  			proj.get(randomInt).lecturer = algorithm.testLecturers.get(i);
  			proj.remove(randomInt);
  		}

  		//currently each lecturer will get 3 each because the project will simply be assigned to whoevers left
  		// until we run out of projects

  		Project chosenProject;
  		Lecturer chosenLecturer;
  		while (proj.size()>0) {
  			int randomProjInt = randomProjectIndex.nextInt(proj.size());
  			int randomLectInt = randomProjectIndex.nextInt(algorithm.testLecturers.size());
  			chosenProject = proj.get(randomProjInt);
  			chosenLecturer = algorithm.testLecturers.get(randomLectInt);
  			chosenLecturer.projects.add(chosenProject);
  			chosenProject.lecturer = chosenLecturer;
  			proj.remove(randomProjInt);
  		}

      createRankingLists();
    }

    static void createRankingLists() {

      for (Student s: algorithm.unassigned) {
        s.rankingList = new int[s.preferenceList.size()];
        for (int i = 0; i < s.rankingList.length; i++) {
          s.rankingList[i] = i;  // Initially set rankings so index 0 is favourite, 1 is second favourite etc..
        }
      }
      for (Student s: algorithm.assignedStudents) {
        s.rankingList = new int[s.preferenceList.size()];
        for (int i = 0; i < s.rankingList.length; i++) {
          s.rankingList[i] = i;  // Initially set rankings so index 0 is favourite, 1 is second favourite etc..
        }
      }
      for (Lecturer l: algorithm.testLecturers) {
        l.rankingList = new int[l.projects.size()];
        for (int i = 0; i < l.rankingList.length; i++) {
          l.rankingList[i] = i;
        }
      }
    }
}
