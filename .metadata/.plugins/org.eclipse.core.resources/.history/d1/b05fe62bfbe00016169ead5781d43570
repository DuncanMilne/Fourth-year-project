import java.util.ArrayList;

import gurobi.GRB;
import gurobi.GRBEnv;
import gurobi.GRBException;
import gurobi.GRBLinExpr;
import gurobi.GRBModel;
import gurobi.GRBVar;

public class GurobiModel extends Algorithm {

    /** <p>The gurobi environment.</p> */
    GRBEnv env;
    /** <p>The gurobi model.</p> */
    GRBModel grbmodel;
    
    boolean feasible = true;
	
    public GurobiModel() {
		super();
        try {
			env = new GRBEnv();
	        grbmodel = new GRBModel(env);
		} catch (GRBException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
	
	public void assignConstraints(Algorithm a) throws GRBException {

		upperLowerConstraints(a);
		addMaxSizeConstraint(a);
        minSumStudentRanks(a);    
        grbmodel.optimize();
        int status = grbmodel.get(GRB.IntAttr.Status);
        if (status != GRB.Status.OPTIMAL) {
            feasible = false;
            System.out.println("no solution found in the following instance:");
        }
        else {
            setStudentAssignments(a);
        }
        

        // write model then dispose of model and environment
        //m.setInfoString(infoString);
        //grbmodel.write("SPA_IP_HR.lp");
        grbmodel.dispose();
        env.dispose();    
	}
	
	/**
    * <p>Adds upper and lower quota constraints to projects and lecturers, and student upper quota.</p>
    */
    private void upperLowerConstraints(Algorithm a) throws GRBException {
        // ----------------------------------------------------------------------------------------
        // each student is matched to 1 or less projects
    	
        for (Student s:a.untouchedStudents) {
            GRBLinExpr sumVarsForStudent = new GRBLinExpr();
            // could do for each student
        	for (Project p: s.preferenceList) {
        		GRBVar v = grbmodel.addVar(0.0, 1.0, 0.0, GRB.BINARY, "pref" + p.name);
        		s.grbvars.add(v);
        		sumVarsForStudent.addTerm(1, v);
        	}
            // each student is matched to 1 or less projects
            grbmodel.addConstr(sumVarsForStudent, GRB.LESS_EQUAL, 1.0, "ConstraintStudent " + s.name); //can change this to be less than or equal to the capacity of each project
        }

        // ----------------------------------------------------------------------------------------
        // for each lecturer

        for (Lecturer l: a.testLecturers) {
            GRBLinExpr numStudentsForLect = new GRBLinExpr();
	        // ----------------------------------------------------------------------------------------
	        // for each project 
	        for (Project p: a.projects) {
	            GRBLinExpr numStudentsForProj = new GRBLinExpr();
	            // for every student, if this project is in their pref list, add term
	            for (Student s: a.untouchedStudents) {
	            	if (s.preferenceList.contains(p)){
	            		numStudentsForProj.addTerm(1, grbmodel.addVar(0.0, 1.0, 0.0, GRB.BINARY, "pref" + s.name));
	            		if (l.projects.contains(p)){
		            		numStudentsForLect.addTerm(1, grbmodel.addVar(0.0, 1.0, 0.0, GRB.BINARY, "pref" + s.name));
	            		}
	            	}
	            }
	            // The number of students a project has must be less than or equal to the max capacity
	            grbmodel.addConstr(numStudentsForProj, GRB.LESS_EQUAL, (double) p.capacity, "ConstraintProjectUQ" + p.name); //need to set this to be the capacity of each project   
	        }
            grbmodel.addConstr(numStudentsForLect, GRB.LESS_EQUAL, (double) l.capacity, "ConstraintLecturerUQ" + l.name);
        }

    }

    /**
    * <p>Optimises on the maximum size and adds relevant constraint.</p>
    */
    public void addMaxSizeConstraint(Algorithm a) throws GRBException {
    	 GRBLinExpr sumAllVariables = new GRBLinExpr();
         for (Student s: a.untouchedStudents) {
        	 for (Project p: a.projects)
                 sumAllVariables.addTerm(1, grbmodel.addVar(0.0, 1.0, 0.0, GRB.BINARY, "pref" + s.name));
         }

         grbmodel.setObjective(sumAllVariables, GRB.MAXIMIZE);
         grbmodel.optimize();
         int status = grbmodel.get(GRB.IntAttr.Status); 
         System.out.println("BOKE");
         // if there is a feasible solution
         if (status == GRB.Status.OPTIMAL) {
             double maxSize = grbmodel.get(GRB.DoubleAttr.ObjVal);
             System.out.println("max size is " + maxSize);
             // add a new constraint into the model to say that the size of matching must be at least the bound found above
             grbmodel.addConstr(sumAllVariables, GRB.GREATER_EQUAL, (double) maxSize, "ConstraintSize");

         }
    }


    /**
    * <p>Optimises on the minimum student cost and adds relevant constraint.</p>
    */
    public void minSumStudentRanks(Algorithm a) throws GRBException {
    	GRBLinExpr sumAllRanks = new GRBLinExpr();
        for (Student s:a.untouchedStudents) {
        	for (Project p: s.preferenceList)
        		sumAllRanks.addTerm(s.preferenceList.indexOf(p)+1, grbmodel.addVar(0.0, 1.0, 0.0, GRB.BINARY, "pref" + s.name)); //the one should be replaced by the students rank of this project
        }

        grbmodel.setObjective(sumAllRanks, GRB.MINIMIZE);
        grbmodel.optimize();
        int status = grbmodel.get(GRB.IntAttr.Status); 

        // if there is a feasible solution
        if (status == GRB.Status.OPTIMAL) {
            double minSumRank = grbmodel.get(GRB.DoubleAttr.ObjVal);

            grbmodel.addConstr(sumAllRanks, GRB.LESS_EQUAL, (double) minSumRank, "ConstraintSumRanks");
        }
    }
    

    /**
    * <p>Set the current student assignments in the model.</p>
    */
    // duncans comment - the assignments have already been chosen by the constraints, this is just setting them
    public void setStudentAssignments(Algorithm a) throws GRBException {
    	// ready to save the assigned students to the studentAssignments array in the model
          
        // set the student assignments
        for (int x = 0; x < a.untouchedStudents.size(); x++) {
        	Student s = a.untouchedStudents.get(x);
            int prefLength = s.preferenceList.size();
            boolean matched = false;
            // for every preference of current student
            for (int projInd = 0; projInd < prefLength; projInd++) {
                double resultPref = s.grbvars.get(projInd).get(GRB.DoubleAttr.X);
                System.out.println(resultPref);
                if (resultPref > 0.5) {
                    s.proj = s.preferenceList.get(projInd);   
                    matched = true;   
                }
            }
        }
    }
}


















